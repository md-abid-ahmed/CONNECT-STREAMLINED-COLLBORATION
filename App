import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Brush
} from 'recharts';
import { CSVLink } from 'react-csv';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';
import './AppOverview.css';

interface AppOption {
  value: string;
  label: string;
}

interface UtilizationData {
  app: string;
  datetime: string;
  instance: number;
  instance_type: string;
  state: string;
  value: number;
}

interface ProcessedData {
  name: string;
  [key: string]: number | string;
}

const AppOverview: React.FC = () => {
  const [appOptions, setAppOptions] = useState<AppOption[]>([]);
  const [selectedAppId, setSelectedAppId] = useState<string>('');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [utilizationData, setUtilizationData] = useState<UtilizationData[]>([]);
  const [dateRangeType, setDateRangeType] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [showInsights, setShowInsights] = useState(false);
  const [selectedInstances, setSelectedInstances] = useState<number[]>([]);
  const [viewMode, setViewMode] = useState<'all' | 'selected'>('all');

  useEffect(() => {
    fetchApps();
  }, []);

  const fetchApps = async () => {
    try {
      const response = await axios.get('/fetch_apps');
      if (response.data && Array.isArray(response.data.Data)) {
        const apps = response.data.Data.map((app: { _id: string }) => ({
          value: app._id,
          label: `AppID: ${app._id}`
        }));
        setAppOptions(apps);
      } else {
        console.error('Unexpected response format from /fetch_apps');
      }
    } catch (error) {
      console.error('Error fetching apps:', error);
    }
  };

  const formatDate = (date: Date): string => {
    return date.toISOString().slice(0, 19).replace('T', ' ') + '.00';
  };

  const fetchUtilizationData = async () => {
    if (!selectedAppId || !startDate || !endDate) return;

    const postData = {
      appID: selectedAppId,
      from_time: formatDate(startDate),
      to_time: formatDate(endDate)
    };

    try {
      const response = await axios.post('/fetch_utilisation', postData);
      if (response.data && Array.isArray(response.data.data)) {
        setUtilizationData(response.data.data);
      } else {
        console.error('Unexpected response format from /fetch_utilisation');
      }
    } catch (error) {
      console.error('Error fetching utilization data:', error);
    }
  };

  const handleCalculate = () => {
    fetchUtilizationData();
  };

  const processUtilizationData = (): ProcessedData[] => {
    const dataMap: { [key: string]: ProcessedData } = {};

    utilizationData.forEach(item => {
      if (!dataMap[item.datetime]) {
        dataMap[item.datetime] = { name: item.datetime };
      }
      dataMap[item.datetime][`Instance ${item.instance}`] = item.value;
    });

    return Object.values(dataMap);
  };

  const calculateInsights = () => {
    if (utilizationData.length === 0) return { averageUsage: '0', maxUsageDay: 'N/A', minUsageDay: 'N/A' };

    const totalUsage = utilizationData.reduce((acc, d) => acc + d.value, 0);
    const averageUsage = totalUsage / utilizationData.length;
    const maxUsageDay = utilizationData.reduce((max, d) => d.value > max.value ? d : max, utilizationData[0]);
    const minUsageDay = utilizationData.reduce((min, d) => d.value < min.value ? d : min, utilizationData[0]);

    return {
      averageUsage: averageUsage.toFixed(2),
      maxUsageDay: `${maxUsageDay.datetime} (${maxUsageDay.value}%)`,
      minUsageDay: `${minUsageDay.datetime} (${minUsageDay.value}%)`,
    };
  };

  const processedData = processUtilizationData();

  const calculateStats = () => {
    const allValues = processedData.flatMap(item => 
      Object.entries(item)
        .filter(([key]) => {
          if (viewMode === 'all') return key.startsWith('Instance');
          return key.startsWith('Instance') && selectedInstances.includes(parseInt(key.split(' ')[1]));
        })
        .map(([, value]) => value as number)
    );

    const peakLoad = allValues.length > 0 ? Math.max(...allValues) : 0;
    const minLoad = allValues.length > 0 ? Math.min(...allValues) : 0;
    const costIncurred = allValues.reduce((acc, val) => acc + val * 0.5, 0);

    return { peakLoad, minLoad, costIncurred };
  };

  const { peakLoad, minLoad, costIncurred } = calculateStats();

  const potentialSavings = processedData.reduce((acc, d) => 
    acc + Object.values(d)
      .filter((v): v is number => typeof v === 'number' && v < 50)
      .reduce((sum, v) => sum + v * 0.5 * 0.3, 0)
  , 0);

  const exportData = processedData.map(d => ({ ...d, instance: 'all instances' }));

  const instances = Array.from(new Set(utilizationData.map(d => d.instance)));

  const handleInstanceChange = (instance: number) => {
    setSelectedInstances(prev => 
      prev.includes(instance) 
        ? prev.filter(i => i !== instance)
        : [...prev, instance]
    );
    setViewMode('selected');
  };

  const handleViewModeChange = (mode: 'all' | 'selected') => {
    setViewMode(mode);
    if (mode === 'all') {
      setSelectedInstances([]);
    }
  };

  return (
    <div className="app-container">
      <div className="app-overview">
        <div className="header">
          <div className="top-row">
            <div className="app-selector">
              <select
                value={selectedAppId}
                onChange={(e) => setSelectedAppId(e.target.value)}
              >
                <option value="" disabled>Select App ID</option>
                {appOptions.map(({ value, label }) => (
                  <option key={value} value={value}>{label}</option>
                ))}
              </select>
            </div>
            <div className="date-range">
              <DatePicker
                selected={startDate}
                onChange={(date: Date | null) => setStartDate(date ?? undefined)}
                selectsStart
                startDate={startDate}
                endDate={endDate}
                placeholderText="Start Date"
              />
              <DatePicker
                selected={endDate}
                onChange={(date: Date | null) => setEndDate(date ?? undefined)}
                selectsEnd
                startDate={startDate}
                endDate={endDate}
                minDate={startDate}
                placeholderText="End Date"
              />
            </div>
            <div className="stats">
              <div className="stat">
                <span>Peak Load</span>
                <span>{peakLoad.toFixed(2)}%</span>
              </div>
              <div className="stat">
                <span>Min Load</span>
                <span>{minLoad.toFixed(2)}%</span>
              </div>
              <div className="stat">
                <span>Cost Incurred</span>
                <span>${costIncurred.toFixed(2)}</span>
              </div>
            </div>
          </div>
          <div className="bottom-row">
            <div className="date-controls">
              {['daily', 'weekly', 'monthly'].map((type) => (
                <button
                  key={type}
                  className={`date-range-btn ${dateRangeType === type ? 'active' : ''}`}
                  onClick={() => setDateRangeType(type as 'daily' | 'weekly' | 'monthly')}
                >
                  {type.charAt(0).toUpperCase() + type.slice(1)}
                </button>
              ))}
            </div>
            <button className="btn primary" onClick={handleCalculate}>Apply Filter</button>
            <button className="btn secondary" onClick={() => setShowInsights(true)}>Quick Insights</button>
          </div>
        </div>

        <div className="instance-selection">
          <div className="view-mode">
            <label>
              <input
                type="radio"
                checked={viewMode === 'all'}
                onChange={() => handleViewModeChange('all')}
              />
              All Instances
            </label>
            <label>
              <input
                type="radio"
                checked={viewMode === 'selected'}
                onChange={() => handleViewModeChange('selected')}
              />
              Selected Instances
            </label>
          </div>
          <div className="instance-checkboxes">
            {instances.map((instance) => (
              <label key={instance}>
                <input
                  type="checkbox"
                  checked={selectedInstances.includes(instance)}
                  onChange={() => handleInstanceChange(instance)}
                  disabled={viewMode === 'all'}
                />
                Instance {instance}
              </label>
            ))}
          </div>
        </div>

        <div className="chart-container">
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Legend />
              {instances.map((instance, index) => (
                (viewMode === 'all' || selectedInstances.includes(instance)) && (
                  <Line
                    key={instance}
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Brush
} from 'recharts';
import { CSVLink } from 'react-csv';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';
import './AppOverview.css';

interface AppOption {
  value: string;
  label: string;
}

interface UtilizationData {
  app: string;
  datetime: string;
  instance: number;
  instance_type: string;
  state: string;
  value: number;
}

interface ProcessedData {
  name: string;
  [key: string]: number | string;
}

const AppOverview: React.FC = () => {
  const [appOptions, setAppOptions] = useState<AppOption[]>([]);
  const [selectedAppId, setSelectedAppId] = useState<string>('');
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  const [utilizationData, setUtilizationData] = useState<UtilizationData[]>([]);
  const [dateRangeType, setDateRangeType] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [showInsights, setShowInsights] = useState(false);
  const [selectedInstances, setSelectedInstances] = useState<number[]>([]);
  const [viewMode, setViewMode] = useState<'all' | 'selected'>('all');

  useEffect(() => {
    fetchApps();
  }, []);

  const fetchApps = async () => {
    try {
      const response = await axios.get('/fetch_apps');
      if (response.data && Array.isArray(response.data.Data)) {
        const apps = response.data.Data.map((app: { _id: string }) => ({
          value: app._id,
          label: `AppID: ${app._id}`
        }));
        setAppOptions(apps);
      } else {
        console.error('Unexpected response format from /fetch_apps');
      }
    } catch (error) {
      console.error('Error fetching apps:', error);
    }
  };

  const formatDate = (date: Date): string => {
    return date.toISOString().slice(0, 19).replace('T', ' ') + '.00';
  };

  const fetchUtilizationData = async (rangeType: 'daily' | 'weekly' | 'monthly' = dateRangeType) => {
    if (!selectedAppId || !startDate || !endDate) return;

    let fromDate = new Date(startDate);
    let toDate = new Date(endDate);

    switch (rangeType) {
      case 'weekly':
        fromDate = new Date(fromDate.setDate(fromDate.getDate() - fromDate.getDay()));
        toDate = new Date(toDate.setDate(toDate.getDate() + (6 - toDate.getDay())));
        break;
      case 'monthly':
        fromDate = new Date(fromDate.getFullYear(), fromDate.getMonth(), 1);
        toDate = new Date(toDate.getFullYear(), toDate.getMonth() + 1, 0);
        break;
      // 'daily' is the default, so we don't need to modify the dates
    }

    const postData = {
      appID: selectedAppId,
      from_time: formatDate(fromDate),
      to_time: formatDate(toDate),
      date_range_type: rangeType
    };

    try {
      const response = await axios.post('/fetch_utilisation', postData);
      if (response.data && Array.isArray(response.data.data)) {
        setUtilizationData(response.data.data);
      } else {
        console.error('Unexpected response format from /fetch_utilisation');
      }
    } catch (error) {
      console.error('Error fetching utilization data:', error);
    }
  };

  const handleDateRangeTypeChange = (type: 'daily' | 'weekly' | 'monthly') => {
    setDateRangeType(type);
    if (selectedAppId && startDate && endDate) {
      fetchUtilizationData(type);
    }
  };

  const processUtilizationData = (): ProcessedData[] => {
    const dataMap: { [key: string]: ProcessedData } = {};

    utilizationData.forEach(item => {
      if (!dataMap[item.datetime]) {
        dataMap[item.datetime] = { name: item.datetime };
      }
      dataMap[item.datetime][`Instance ${item.instance}`] = item.value;
    });

    return Object.values(dataMap);
  };

  const calculateInsights = () => {
    if (utilizationData.length === 0) return { averageUsage: '0', maxUsageDay: 'N/A', minUsageDay: 'N/A' };

    const totalUsage = utilizationData.reduce((acc, d) => acc + d.value, 0);
    const averageUsage = totalUsage / utilizationData.length;
    const maxUsageDay = utilizationData.reduce((max, d) => d.value > max.value ? d : max, utilizationData[0]);
    const minUsageDay = utilizationData.reduce((min, d) => d.value < min.value ? d : min, utilizationData[0]);

    return {
      averageUsage: averageUsage.toFixed(2),
      maxUsageDay: `${maxUsageDay.datetime} (${maxUsageDay.value}%)`,
      minUsageDay: `${minUsageDay.datetime} (${minUsageDay.value}%)`,
    };
  };

  const processedData = processUtilizationData();

  const calculateStats = () => {
    const allValues = processedData.flatMap(item => 
      Object.entries(item)
        .filter(([key]) => {
          if (viewMode === 'all') return key.startsWith('Instance');
          return key.startsWith('Instance') && selectedInstances.includes(parseInt(key.split(' ')[1]));
        })
        .map(([, value]) => value as number)
    );

    const peakLoad = allValues.length > 0 ? Math.max(...allValues) : 0;
    const minLoad = allValues.length > 0 ? Math.min(...allValues) : 0;
    const costIncurred = allValues.reduce((acc, val) => acc + val * 0.5, 0);

    return { peakLoad, minLoad, costIncurred };
  };

  const { peakLoad, minLoad, costIncurred } = calculateStats();

  const potentialSavings = processedData.reduce((acc, d) => 
    acc + Object.values(d)
      .filter((v): v is number => typeof v === 'number' && v < 50)
      .reduce((sum, v) => sum + v * 0.5 * 0.3, 0)
  , 0);

  const exportData = processedData.map(d => ({ ...d, instance: 'all instances' }));

  const instances = Array.from(new Set(utilizationData.map(d => d.instance)));

  const handleInstanceChange = (instance: number) => {
    setSelectedInstances(prev => 
      prev.includes(instance) 
        ? prev.filter(i => i !== instance)
        : [...prev, instance]
    );
    setViewMode('selected');
  };

  const handleViewModeChange = (mode: 'all' | 'selected') => {
    setViewMode(mode);
    if (mode === 'all') {
      setSelectedInstances([]);
    }
  };

  return (
    <div className="app-container">
      <div className="app-overview">
        <div className="header">
          <div className="top-row">
            <div className="app-selector">
              <select
                value={selectedAppId}
                onChange={(e) => setSelectedAppId(e.target.value)}
              >
                <option value="" disabled>Select App ID</option>
                {appOptions.map(({ value, label }) => (
                  <option key={value} value={value}>{label}</option>
                ))}
              </select>
            </div>
            <div className="date-range">
              <DatePicker
                selected={startDate}
                onChange={(date: Date | null) => setStartDate(date)}
                selectsStart
                startDate={startDate}
                endDate={endDate}
                placeholderText="Start Date"
              />
              <DatePicker
                selected={endDate}
                onChange={(date: Date | null) => setEndDate(date)}
                selectsEnd
                startDate={startDate}
                endDate={endDate}
                minDate={startDate}
                placeholderText="End Date"
              />
            </div>
            <div className="stats">
              <div className="stat">
                <span>Peak Load</span>
                <span>{peakLoad.toFixed(2)}%</span>
              </div>
              <div className="stat">
                <span>Min Load</span>
                <span>{minLoad.toFixed(2)}%</span>
              </div>
              <div className="stat">
                <span>Cost Incurred</span>
                <span>${costIncurred.toFixed(2)}</span>
              </div>
            </div>
          </div>
          <div className="bottom-row">
            <div className="date-controls">
              {['daily', 'weekly', 'monthly'].map((type) => (
                <button
                  key={type}
                  className={`date-range-btn ${dateRangeType === type ? 'active' : ''}`}
                  onClick={() => handleDateRangeTypeChange(type as 'daily' | 'weekly' | 'monthly')}
                >
                  {type.charAt(0).toUpperCase() + type.slice(1)}
                </button>
              ))}
            </div>
            <button className="btn primary" onClick={() => fetchUtilizationData()}>Apply Filter</button>
            <button className="btn secondary" onClick={() => setShowInsights(true)}>Quick Insights</button>
          </div>
        </div>

        <div className="instance-selection">
          <div className="view-mode">
            <label>
              <input
                type="radio"
                checked={viewMode === 'all'}
                onChange={() => handleViewModeChange('all')}
              />
              All Instances
            </label>
            <label>
              <input
                type="radio"
                checked={viewMode === 'selected'}
                onChange={() => handleViewModeChange('selected')}
              />
              Selected Instances
            </label>
          </div>
          <div className="instance-checkboxes">
            {instances.map((instance) => (
              <label key={instance}>
                <input
                  type="checkbox"
                  checked={selectedInstances.includes(instance)}
                  onChange={() => handleInstanceChange(instance)}
                  disabled={viewMode === 'all'}
                />
                Instance {instance}
              </label>
            ))}
          </div>
        </div>

        <div className="chart-container">
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Legend />
              {instances.map((instance, index) => (
                (viewMode === 'all' || selectedInstances.includes(instance)) && (
                  <Line
                    key={instance}
                    type="monotone"
                    dataKey={`Instance ${instance}`}
                    stroke={`hsl(${index * 360 / instances.length}, 70%, 50%)`}
                    dot={false}
                  />
                )
              ))}
              <Brush dataKey="name" height={30} stroke="#8884d8" />
            </LineChart>
          </ResponsiveContainer>
        </div>

        {showInsights && (
          <div className="insights">
            <h3>Quick Insights</h3>
            <p>Average Usage: {calculateInsights().averageUsage}%</p>
            <p>Max Usage Day: {calculateInsights().maxUsageDay}</p>
            <p>Min Usage Day: {calculateInsights().minUsageDay}</p>
            <p>Potential Savings: ${potentialSavings.toFixed(2)}</p>
            <button className="btn secondary" onClick={() => setShowInsights(false)}>Close Insights</button>
          </div>
        )}

        <div className="export-container">
          <CSVLink data={exportData} filename={"utilization_data.csv"}>
            <button className="btn secondary">Export CSV</button>
          </CSVLink>
        </div>
      </div>
    </div>
  );
};

export default AppOverview;

export default AppOverview;

:root {
  --wf-red: #D71E2B;
  --wf-gold: #FFC424;
  --wf-gray: #6B7280;
  --wf-light-gray: #F3F4F6;
  --wf-dark-gray: #374151;
}

.app-container {
  font-family: Arial, sans-serif;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background-color: #FFFFFF;
}

.app-overview {
  border: 1px solid var(--wf-light-gray);
  border-radius: 8px;
  overflow: hidden;
}

.header {
  background-color: var(--wf-light-gray);
  padding: 20px;
}

.top-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.app-selector select {
  padding: 8px;
  border: 1px solid var(--wf-gray);
  border-radius: 4px;
  font-size: 14px;
}

.date-range {
  display: flex;
  gap: 10px;
}

.date-range input {
  padding: 8px;
  border: 1px solid var(--wf-gray);
  border-radius: 4px;
  font-size: 14px;
}

.stats {
  display: flex;
  gap: 20px;
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.stat span:first-child {
  font-size: 12px;
  color: var(--wf-gray);
}

.stat span:last-child {
  font-size: 16px;
  font-weight: bold;
  color: var(--wf-dark-gray);
}

.bottom-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.date-controls {
  display: flex;
  gap: 10px;
}

.date-range-btn {
  background-color: #FFFFFF;
  border: 1px solid var(--wf-gray);
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.date-range-btn.active {
  background-color: var(--wf-red);
  color: #FFFFFF;
  border-color: var(--wf-red);
}

.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.btn.primary {
  background-color: var(--wf-red);
  color: #FFFFFF;
}

.btn.secondary {
  background-color: var(--wf-gold);
  color: var(--wf-dark-gray);
}

.instance-selection {
  padding: 20px;
  border-bottom: 1px solid var(--wf-light-gray);
}

.view-mode {
  display: flex;
  gap: 20px;
  margin-bottom: 10px;
}

.instance-checkboxes {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.chart-container {
  padding: 20px;
}

.insights {
  background-color: var(--wf-light-gray);
  padding: 20px;
  margin-top: 20px;
  border-radius: 8px;
}

.insights h3 {
  color: var(--wf-red);
  margin-top: 0;
}

.export-container {
  padding: 20px;
  text-align: right;
}

@media (max-width: 768px) {
  .top-row, .bottom-row {
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }

  .stats {
    justify-content: space-between;
  }
}
